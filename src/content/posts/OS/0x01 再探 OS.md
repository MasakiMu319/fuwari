---
title: 0x01 - 再探 OS
published: 2024-08-20 17:00:00
description: '再探 OS 的世界。'
image: ''
tags: ['OS']
category: 'OS'
draft: False

---

## 文件

文件是 `OS` 的核心抽象之一，本质上是将进程与各种设备和组件之间的交互转换为在文件上的二进制数据。

也就是对上层的软件屏蔽了所有的底层实现，通过管道（`pipe`），让进程与底层间通过文件上的二进制数据进行流转。

文件可以被多个进程共享，在软件的基础上进一步抽象出：文件描述符（`file description`，缩写 `fd`）。`fd` 是对文件的一个视图，包含文件指向和偏移量。其中，偏移量是`隐式维护`的。

:::tip

`Kafka` 中抽象的 `Topic`，也是通过 `consumer` 维护一个关联到 `Topic` 的偏移量，用于表示当前已消费的内容。

:::

>   Q：不管是多进程还是 Kafka 中的 consumer 都会涉及同时写入同一个文件的问题，那么都是怎么解决的呢？

文件描述符是一个进程范围的整数。我们固定 0 是标准输入，1 是标准输出。这样可以通过管道来将数据流重定向，从而对不同的处理过程（cmd）进行自由组合。我们以常用的 `lsof | grep 'Surge'` 命令作为拆解：

1.   `grep` 作为我们本次使用的处理过程，只用于对数据流进行查找操作，因为每个处理工具都只需要关注一件小事；
2.   通过管道重定向 lsof 的输出到 `grep` 的输入：需要输入就从标准输入读取，需要输出就输出到标准输出；
3.   管道负责将一个个小工具串成一个复杂的处理过程。

### 文件操作语义

1.   `open`：以指定模式打开文件，会返回一个相应的文件描述符，并且隐式初始化该 `fd` 的 `offset` 为 0；
2.   `read(fd, buf, n)`：从文件描述符 `fd` 关联的文件的偏移量处读取最多 `n` 个字节到 `buf` 中；读取成功后会前移 `fd` 关联的偏移量。对调用者来说无需要关心偏移量的变更，只需要不断读取 `fd` 的内容即可，读取成功会返回实际读到的字节数；如果失败，则返回值小于 0；
3.   `write(fd, buf, n)`：将 `buf` 中的 `n` 个字节内容写入到文件描述符 `fd` 关联的文件和偏移量处；并且会自动前移 `fd` 相应字节的偏移量，写入成功会返回 `n`；如果失败，返回值小于 `n`；
4.   `close(fd)`：释放 `fd` 和所占用的资源，比如文件指针和偏移量等信息。且进程之后可以复用该 `fd` 标号。

