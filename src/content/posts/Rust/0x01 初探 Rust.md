---
title: 0x01 - 初探 Rust
published: 2024-08-18 10:00:00
description: '初探 Rust 世界。'
image: ''
tags: ['Rust', 'Basic skills']
category: 'Rust'
draft: false
---

## 程序运行过程中的内存分配

因为栈上分配的内存和回收，只需要移动栈顶指针就行，这就决定了在栈的内存分配与回收都必须精确计算这个指针的增减量，所以通常固定大小的值才会存放在栈上。

非固定的值或者特别大的值会存放在专门的大内存区域，也就是堆。

对于线程中执行的函数调用，每个被调用函数都会被分配一个 frame 栈帧，函数调用结束后自动释放。因此栈帧实际上是个运行时的事物，函数中的参数、局部变量等都会放在这个栈帧中，等待调用完成后释放。

![image-20240818113540651](https://raw.githubusercontent.com/MasakiMu319/fuwari/main/src/assets/post-images/202408181135374.png)

栈空间中的 frame 栈帧按照函数调用关系呈现一个层级关系，例如上面所展示的程序运行时的某个状态，`main -> fn1 -> fn2 -> fn3` 之间的调用形成的栈帧都在同一栈空间了（这里是单线程的情况下）。

:::tip

1.   堆是整个进程中的所有线程所共享的资源；
2.   栈是每个线程独有的资源；

以 `Golang` 中的 `goroutine` 为例，当使用 `go` 关键字启动 `func` 时，此时调用 `func` 分配的 `frame` 是归属于新创建的 `goroutine`。假如 `func` 中调用了其他的 `func`，那么调用产生的 `frame` 同样归属于当前的 `goroutine` 栈空间。

而因为堆空间是进程内部的共享资源，那么线程之间也就可以通过堆空间来进行通信和数据共享，在并发场景下也需要注意数据共享所带来的同步、数据竞争问题。

:::

### 静态数据区

这里提一嘴静态资源区的概念，Rust 中的字符串字面量默认会存放在静态资源区，静态资源区中的字符串总是贯穿整个程序运行的生命周期，直到程序结束的时候才会被释放。也因此不需要归属于某个变量。

对于这种数据类型，我们只能拿到其借用形式 `&'static str`，这里的 `‘static` 表示这个引用可以贯穿整个程序的生命周期。

### 内存泄露

在上面的图中，我们可以看到部分栈帧中直接/间接引用了部分堆空间的资源，资源 `E` 则是没有被任何栈帧引用，此时我们就称其为被泄露的资源，也就是内存泄露。 

被泄露的资源会随着进程一直存在，直到进程自身原因停止，才会被 OS 回收掉。

因此程序内存管理的复杂性主要就体现在对堆内存的管理上 —— 既要高效，又要安全。

## Rust 中的变量定义

`Rust` 中所有声明的新变量默认为不可变类型，但是 `Shadowing` 的特性使得开发者可以通过重新声明同名变量去覆盖原有的变量。

```rust
fn main() {
  let x = 5;
  // x = 6 is not allowed.
  // but you can try with:
  let x = 6;
  // or
  let x = 'x'
}
```

:::note

其实我个人是对所谓变量不可变性带来的好处没有那么认可，可能提高了一些代码的可读性；`Shadowing` 说是特性，但实际上就是更改同名变量所映射的内容，反而可能导致大型项目中，修改某分支时新声明的不同类型的同名变量覆盖了原有变量，从而引发错误。

:::

### 可变修饰符

`Rust` 中采用 `mut` 作为可变修饰符，在声明变量时使用 `mut`，则意味着该变量具备可变性，允许其值更新为同类型值。

## 所有权机制

`Rust` 世界的底座：所有权，定义如下：

:::important

-   Rust 中，每个值都有一个所有者；
-   任何一个时刻，每个值有且仅有一个所有者；
-   当所有者在其作用域（scope）结束的时候，其管理的值都会被一起释放掉。

释放的行为在 Rust 中被称为 drop，拥有者决定被拥有者的声明周期，其他所有人都必须尊重其决定。

:::

我们从一个简单的🌰开始：

```rust
fn main() {
	let s1 = String::from("Hello, world!")
  let s2 = s1
  // We can't print {s1}
  println!("{s2}")
}
```

在其他语言中，正确打印 `s1` 与 `s2` 被视为是理所当然的事情。但是在 `Rust` 中，上述代码无法打印 `s1` 的内容。让我们一步步来分析这个过程：

1.   由于字符串是变长的，无法获得准确的内存占用大小，所以必须分配在堆空间中；
2.   `s1` 此时拥有这个字符串的所有权；
3.   `s2` 从 `s1` 获得字符串的所有权；
4.   原有的 `s1` 字符串此时为空，只有通过 `s2` 才能获取到堆空间的字符串；
5.   `s1` 和 `s2` 的作用域结束，回收栈帧上的空间，并要求通过 `s2` 回收其绑定的堆内存中的字符串资源。

:::tip

当 `s1` 的所有权被转移以后，`s1` 不再指向任何资源，但它仍然是位于当前线程栈帧中的一个局部变量，只不过是无效的变量；它所占用的内存空间大小还是原本的 `String` 类型的大小，同时 `Rust` 编译器会阻止我们去使用它。

类比一个信封，我们取走了里面的信，但是信封还在。

:::

:::warning

所有权其实是内存结构之上的更上层概念，并不是说只有在堆中分配的资源才有所有权。实际上，栈上的资源也是有所有权的。

:::

:::note

默认做复制所有权操作的类型有：

-   整数类型，布尔类型，浮点数类型，字符类型；
-   由上述类型组成的元组类型（tuple）；
-   由上述类型组成的数组类型（array）；
-   不可变引用类型；

对于固定尺寸基础类型（小尺寸类型），它们的值默认是可复制的，这主要是为了编程方便。对于非固定尺寸类型或大尺寸类型的变量再赋值时，默认使用移动操作。除非显式地clone，否则它只保持一份所有权。

:::

### Box 类型

Rust 中通过 `Box<T>` 来指向存储在堆上的 T 类型值的指针，可用调用 `Box::new(v)` 分配一些堆空间，将值 `v` 移入该空间，并返回一个指向该堆空间的 `Box`。因为 `Box` 拥有它所指向的空间，所以，当丢弃 `Box` 的时候，也会释放此空间。

## 借用与引用


