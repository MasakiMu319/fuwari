---
title: 0x01 - 初探 Rust
published: 2024-08-18 10:00:00
description: '初探 Rust 世界。'
image: ''
tags: ['Rust', 'Basic skills']
category: 'Rust'
draft: false
---

## 程序运行过程中的内存分配

因为栈上分配的内存和回收，只需要移动栈顶指针就行，这就决定了在栈的内存分配与回收都必须精确计算这个指针的增减量，所以通常固定大小的值才会存放在栈上。

非固定的值或者特别大的值会存放在专门的大内存区域，也就是堆。

对于线程中执行的函数调用，每个被调用函数都会被分配一个 frame 栈帧，函数调用结束后自动释放。因此栈帧实际上是个运行时的事物，函数中的参数、局部变量等都会放在这个栈帧中，等待调用完成后释放。

![image-20240818113540651](https://raw.githubusercontent.com/MasakiMu319/fuwari/main/src/assets/post-images/202408181135374.png)

栈空间中的 frame 栈帧按照函数调用关系呈现一个层级关系，例如上面所展示的程序运行时的某个状态，`main -> fn1 -> fn2 -> fn3` 之间的调用形成的栈帧都在同一栈空间了（这里是单线程的情况下）。

:::tip

1.   堆是整个进程中的所有线程所共享的资源；
2.   栈是每个线程独有的资源；

以 `Golang` 中的 `goroutine` 为例，当使用 `go` 关键字启动 `func` 时，此时调用 `func` 分配的 `frame` 是归属于新创建的 `goroutine`。假如 `func` 中调用了其他的 `func`，那么调用产生的 `frame` 同样归属于当前的 `goroutine` 栈空间。

而因为堆空间是进程内部的共享资源，那么线程之间也就可以通过堆空间来进行通信和数据共享，在并发场景下也需要注意数据共享所带来的同步、数据竞争问题。

:::

### 静态数据区

这里提一嘴静态资源区的概念，Rust 中的字符串字面量默认会存放在静态资源区，静态资源区中的字符串总是贯穿整个程序运行的生命周期，直到程序结束的时候才会被释放。也因此不需要归属于某个变量。

对于这种数据类型，我们只能拿到其借用形式 `&'static str`，这里的 `‘static` 表示这个引用可以贯穿整个程序的生命周期。

### 内存泄露

在上面的图中，我们可以看到部分栈帧中直接/间接引用了部分堆空间的资源，资源 `E` 则是没有被任何栈帧引用，此时我们就称其为被泄露的资源，也就是内存泄露。 

被泄露的资源会随着进程一直存在，直到进程自身原因停止，才会被 OS 回收掉。

因此程序内存管理的复杂性主要就体现在对堆内存的管理上 —— 既要高效，又要安全。

## Rust 中的变量定义

`Rust` 中所有声明的新变量默认为不可变类型，但是 `Shadowing` 的特性使得开发者可以通过重新声明同名变量去覆盖原有的变量。

```rust
fn main() {
  let x = 5;
  // x = 6 is not allowed.
  // but you can try with:
  let x = 6;
  // or
  let x = 'x'
}
```

:::note

其实我个人是对所谓变量不可变性带来的好处没有那么认可，可能提高了一些代码的可读性；`Shadowing` 说是特性，但实际上就是更改同名变量所映射的内容，反而可能导致大型项目中，修改某分支时新声明的不同类型的同名变量覆盖了原有变量，从而引发错误。

:::

### 可变修饰符

`Rust` 中采用 `mut` 作为可变修饰符，在声明变量时使用 `mut`，则意味着该变量具备可变性，允许其值更新为同类型值。

## 所有权机制

`Rust` 世界的底座：所有权，定义如下：

:::important

-   Rust 中，每个值都有一个所有者；
-   任何一个时刻，每个值有且仅有一个所有者；
-   当所有者在其作用域（scope）结束的时候，其管理的值都会被一起释放掉。

释放的行为在 Rust 中被称为 drop，拥有者决定被拥有者的声明周期，其他所有人都必须尊重其决定。

:::

我们从一个简单的🌰开始：

```rust
fn main() {
	let s1 = String::from("Hello, world!")
  let s2 = s1
  // We can't print {s1}
  println!("{s2}")
}
```

在其他语言中，正确打印 `s1` 与 `s2` 被视为是理所当然的事情。但是在 `Rust` 中，上述代码无法打印 `s1` 的内容。让我们一步步来分析这个过程：

1.   由于字符串是变长的，无法获得准确的内存占用大小，所以必须分配在堆空间中；
2.   `s1` 此时拥有这个字符串的所有权；
3.   `s2` 从 `s1` 获得字符串的所有权；
4.   原有的 `s1` 字符串此时为空，只有通过 `s2` 才能获取到堆空间的字符串；
5.   `s1` 和 `s2` 的作用域结束，回收栈帧上的空间，并要求通过 `s2` 回收其绑定的堆内存中的字符串资源。

:::tip

当 `s1` 的所有权被转移以后，`s1` 不再指向任何资源，但它仍然是位于当前线程栈帧中的一个局部变量，只不过是无效的变量；它所占用的内存空间大小还是原本的 `String` 类型的大小，同时 `Rust` 编译器会阻止我们去使用它。

类比一个信封，我们取走了里面的信，但是信封还在。

:::

:::warning

所有权其实是内存结构之上的更上层概念，并不是说只有在堆中分配的资源才有所有权。实际上，栈上的资源也是有所有权的。

:::

:::note

默认做复制所有权操作的类型有：

-   整数类型，布尔类型，浮点数类型，字符类型；
-   由上述类型组成的元组类型（tuple）；
-   由上述类型组成的数组类型（array）；
-   不可变引用类型；

对于固定尺寸基础类型（小尺寸类型），它们的值默认是可复制的，这主要是为了编程方便。对于非固定尺寸类型或大尺寸类型的变量再赋值时，默认使用移动操作。除非显式地clone，否则它只保持一份所有权。

:::

### Box 类型

Rust 中通过 `Box<T>` 来指向存储在堆上的 T 类型值的指针，可用调用 `Box::new(v)` 分配一些堆空间，将值 `v` 移入该空间，并返回一个指向该堆空间的 `Box`。因为 `Box` 拥有它所指向的空间，所以，当丢弃 `Box` 的时候，也会释放此空间。

## 语句与表达式

表达式与语句之间的核心区别在于表达式有返回值，而语句只是一条指令，需要完成怎么样的操作。

Rust 中的大部分内容都属于表达式，可以认为大括号`{}`包含的内容都属于表达式。例如在定义的函数中：

```rust
fn parse(a: u32) -> u32 {
	a
}
```

大括号返回的值就是 `a`，因为我们没有在 `a` 后面添加分号或者显示地使用 `return` 返回一个具体值。

此时我们考虑下面的内容：

```rust
let a = 32;
let x = {
	a;
}
```

此时的 `x` 是什么呢？

答案是 `()`，因为有分号的存在，所以 `a;` 会被视为一条语句而不是表达式，此时整个代码块就会返回一个单位类型作为结果 `()`.

## String 与 str

提问：这条语句 `let x: str;` 能否正确通过编译？

答案是不可以，因为 `str` 本身属于一个不定长的原始变量，是无法在编译期间确定其大小的。

我们以下面这幅图作为我们理解 `String` 与 `&str` 的开始：

![image-20240924195911484](https://typora-photos.oss-cn-shenzhen.aliyuncs.com/202409241959708.png)

首先需要澄清的一点是，不管 &str 还是 String 类型，它们的底层实际上都是 str 类型，而两者最大的区别在于 String 是拥有的这个 str，而 &str 本身就是对 str 的借用。

对于 &str 来说，它只是能看到底层 str，也就是一个视图，不具备任何修改 str 的能力（`&` 本身就是不可变借用 🌚）；而对于 String 来说，它实际上实现了类似 vector 的效果，额外的 cap 变量也就意味着它具备自动扩容的能力。

那么我猜你想问 String 中的 cap 是在创建 str 的时候就有的吗？还是创建 str 的时候就有的？

我们以如下代码为例：

```rust
fn main() {
    let a: &'static str = "Hello, World";
  	// str don't have capacity!
    // println!("{}", a.capacity());
    let b = a.to_string();
    println!("{}", b.capacity())
}
```

这里比较难以理解的是，我们在将实际的字符串赋给 a 的时候添加了额外的 `‘static` 信息，因为此时的 str 并不是分配在堆上的，而是在全局内存中（即为整个程序的生命周期），因为类型推断的存在，所以如果不显式使用 static，程序一样可以正常编译。

由此我们可以判定，String 其实是对 str 的类型的包装，因此具备 capacity 参数。

## Trait

`Trait` 直接类比其他语言类型中的 `interface` 之类即可。但是比较不同的地方在于，Trait `要求`必须满足以下条件之一：

1.   `实现 Trait 的类型`在当前 crate 下定义；
2.   `需要的实现的 Trait 在`当前 crate 下定义。

这两个原则确保了：假设 `Trait::IsEvent` 在 `crate A` 中定义，但是 `crate B`、`crate C` 都为 `u32` 各自的 `Trait::IsEvent`。但 `crate D` 需要依赖 B、C，当 D 需要调用 u32 中实现的 `IsEvent` 方法时，编译器无法知道 D 要调用 B 还是 C 中定义的方法。

## 借用与引用

To be continued.
